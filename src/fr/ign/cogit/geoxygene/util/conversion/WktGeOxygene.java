/*
 * This file is part of the GeOxygene project source files. 
 * 
 * GeOxygene aims at providing an open framework compliant with OGC/ISO specifications for 
 * the development and deployment of geographic (GIS) applications. It is a open source 
 * contribution of the COGIT laboratory at the Institut Géographique National (the French 
 * National Mapping Agency).
 * 
 * See: http://oxygene-project.sourceforge.net 
 *  
 * Copyright (C) 2005 Institut Géographique National
 *
 * This library is free software; you can redistribute it and/or modify it under the terms
 * of the GNU Lesser General Public License as published by the Free Software Foundation; 
 * either version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with 
 * this library (see file LICENSE if present); if not, write to the Free Software 
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *  
 */

/* Generated By:JavaCC: Do not edit this line. WktGeOxygene.java */
package fr.ign.cogit.geoxygene.util.conversion;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import fr.ign.cogit.geoxygene.spatial.coordgeom.DirectPosition;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_LineString;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_Polygon;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_Aggregate;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiCurve;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiPoint;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiSurface;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Curve;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Point;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Ring;
import fr.ign.cogit.geoxygene.spatial.geomroot.GM_Object;


public class WktGeOxygene implements WktGeOxygeneConstants {
    static class EndOfFile extends Exception {}
    static class EmptyLine extends Exception {}

    /*-----------------------------------------------------*/
    /*- Create Wkt object(s) from GM_Object ---------------*/
    /*-----------------------------------------------------*/

    /*- GM_Aggregate --------------------------------------*/

    static String geometryCollectionTaggedText(GM_Aggregate aggregate)
    {
        StringBuffer result=new StringBuffer();
        result.append("GEOMETRYCOLLECTION ");
        if (IsEmptyUtil.isEmpty(aggregate)) result.append("EMPTY");
        else {
                result.append("(");
                for (int i=0; i<aggregate.size(); i++) {
                    if (i!=0)
                        result.append(", ");
                    result.append(makeWkt(aggregate.get(i)));
                }
                result.append(")");
        }
        return result.toString();
    }

    /*- GM_MultiPoint -------------------------------------*/

    static String multiPointTaggedText(GM_MultiPoint multiPoint)
    {
        GM_Point point;
        StringBuffer result=new StringBuffer();
        result.append("MULTIPOINT ");
        if (IsEmptyUtil.isEmpty(multiPoint)) result.append("EMPTY");
        else {
                result.append("(");
                for (int i=0; i<multiPoint.size(); i++) {
                    point=(GM_Point)multiPoint.get(i);
                    if (i!=0)
                        result.append(", ");
                    result.append(point(point));
                }
                result.append(")");
        }
        return result.toString();
    }

    /*- GM_MultiCurve -------------------------------------*/

    static String multiLineStringTaggedText(GM_MultiCurve multiCurve)
    {
        GM_LineString lineString;
        StringBuffer result=new StringBuffer();
        result.append("MULTILINESTRING ");
        if (IsEmptyUtil.isEmpty(multiCurve)) result.append("EMPTY");
        else {
                result.append("(");
                for (int i=0; i<multiCurve.size(); i++) {
                    lineString=(GM_LineString)multiCurve.get(i);
                    if (i!=0)
                        result.append(", ");
                    result.append(lineStringText(lineString));
                }
                result.append(")");
        }
        return result.toString();
    }

    /*- GM_MultiSurface -----------------------------------*/

        static String multiPolygon(GM_MultiSurface multiSurface)
        {
        StringBuffer result=new StringBuffer();
        for (int i=0; i<multiSurface.size(); i++) {
                        GM_Object surface;
            surface=multiSurface.get(i);
            if (i!=0)
                result.append(", ");
            if (surface instanceof GM_Polygon)
                result.append(polygonText((GM_Polygon)surface));
                else if (surface instanceof GM_MultiSurface)
                        result.append(multiPolygon((GM_MultiSurface)surface));
        }
        return result.toString();
        }

        static String multiPolygonText(GM_MultiSurface multiSurface)
        {
        StringBuffer result=new StringBuffer();
        result.append("(");
                result.append(multiPolygon(multiSurface));
        result.append(")");
                return result.toString();
        }

    static String multiPolygonTaggedText(GM_MultiSurface multiSurface)
    {
        StringBuffer result=new StringBuffer();
        result.append("MULTIPOLYGON ");
        if (IsEmptyUtil.isEmpty(multiSurface)) result.append("EMPTY");
        else {
                        result.append(multiPolygonText(multiSurface));
            }
        return result.toString();
    }

    /*- GM_LineString -------------------------------------*/

    static String lineStringText(GM_LineString lineString)
    {
        GM_Point point;
        StringBuffer result=new StringBuffer();
        result.append("(");
        for (int i=0; i<lineString.sizeControlPoint(); i++) {
            point=(GM_Point)new GM_Point(lineString.getControlPoint(i));
            if (i!=0)
                result.append(", ");
            result.append(point(point));
        }
        result.append(")");
        return result.toString();
    }

    static String lineStringTaggedText(GM_LineString lineString)
    {
        StringBuffer result=new StringBuffer();
        result.append("LINESTRING ");
        if (IsEmptyUtil.isEmpty(lineString)) result.append("EMPTY");
        else result.append(lineStringText(lineString));

        return result.toString();
    }

    /*- GM_Polygon ----------------------------------------*/

    static String polygonText(GM_Polygon polygon)
    {
        GM_LineString lineString;
        GM_Curve prim;

        StringBuffer result=new StringBuffer();
        result.append("(");

        lineString=polygon.exteriorLineString();
        result.append(lineStringText(lineString));

        for (int i=0; i<polygon.sizeInterior(); i++) {
            lineString=polygon.interiorLineString(i);
            result.append(", ");
            result.append(lineStringText(lineString));
        }
        result.append(")");
        return result.toString();
    }

    static String polygonTaggedText(GM_Polygon polygon)
    {
        StringBuffer result=new StringBuffer();
        result.append("POLYGON ");
        if (IsEmptyUtil.isEmpty(polygon)) result.append("EMPTY");
        else result.append(polygonText(polygon));
        return result.toString();
    }

    /*- GM_Point ------------------------------------------*/

    static String point(GM_Point point)
    {
        DirectPosition position=point.getPosition();
        StringBuffer result=new StringBuffer();
        result.append(position.getX());
        result.append(" ");
        result.append(position.getY());
        return result.toString();
    }

    static String pointText(GM_Point point)
    {
        StringBuffer result=new StringBuffer();
        result.append("(");
        result.append(point(point));
        result.append(")");
        return result.toString();
    }

    static String pointTaggedText(GM_Point point)
    {
        StringBuffer result=new StringBuffer();
        result.append("POINT ");
        if (IsEmptyUtil.isEmpty(point)) result.append("EMPTY");
        else result.append(pointText(point));
        return result.toString();
    }

    /*- GM_Object -----------------------------------------*/

    public static String makeWkt(GM_Object object)
    {
        String result="POINT EMPTY";
        if (object instanceof GM_Point)
            result=pointTaggedText((GM_Point)object);
        else if (object instanceof GM_MultiSurface)
            result=multiPolygonTaggedText((GM_MultiSurface)object);
        else if (object instanceof GM_MultiCurve)
            result=multiLineStringTaggedText((GM_MultiCurve)object);
        else if (object instanceof GM_MultiPoint)
            result=multiPointTaggedText((GM_MultiPoint)object);
        else if (object instanceof GM_Polygon)
            result=polygonTaggedText((GM_Polygon)object);
        else if (object instanceof GM_LineString)
            result=lineStringTaggedText((GM_LineString)object);
        else if (object instanceof GM_Aggregate)
            result=geometryCollectionTaggedText((GM_Aggregate)object);
        return result;
    }

    public static String makeWkt(List geomList)
    {
        StringBuffer result=new StringBuffer();
        Iterator i=geomList.iterator();
        while (i.hasNext()) {
                GM_Object geom=(GM_Object)i.next();
                String wkt=makeWkt(geom);
                result.append(wkt);
                result.append('\n');
        }
        return result.toString();
    }

    /*- Read from stream ----------------------------------*/

    public static GM_Object readGeOxygeneFromWkt(BufferedReader in)
    throws IOException,ParseException
    {
        String wkt=in.readLine();
        return makeGeOxygene(wkt);
    }

    public static GM_Object readGeOxygeneFromWkt(InputStream in)
    throws IOException,ParseException
    {
        return readGeOxygeneFromWkt(new BufferedReader(new InputStreamReader(in)));
    }

    public static GM_Object readGeOxygeneFromWkt(String path)
    throws FileNotFoundException,IOException,ParseException
    {
        return readGeOxygeneFromWkt(new FileInputStream(path));
    }

    /*- Write to stream -----------------------------------*/

    public static void writeWkt(String path, boolean append, GM_Object geom)
    throws IOException
    {
                writeWkt(new FileOutputStream(path, append), geom);
    }

    public static void writeWkt(OutputStream out, GM_Object geom)
    throws IOException
    {
        new PrintStream(out).println(makeWkt(geom));
    }

    public static void writeWkt(OutputStream out, List geomList)
    throws IOException
    {
        Iterator i=geomList.iterator();
        while (i.hasNext()) {
            GM_Object geom=(GM_Object)i.next();
            writeWkt(out,geom);
        }
    }

    /*-----------------------------------------------------*/
    /*- Create GM_Object from Wkt object(s) ---------------*/
    /*-----------------------------------------------------*/

    public static List makeGeOxygeneList(String inStrArray[])
        throws ParseException
    {
        ArrayList list=new ArrayList();
        for (int i=0; i<inStrArray.length; i++) {
            list.add(makeGeOxygene(inStrArray[i]));
        }
        return list;
    }

    static GM_Object makeGeOxygene(InputStream in)
    throws ParseException
    {
        WktGeOxygene parser=new WktGeOxygene(in);
        GM_Object geom=null;

        try {
            geom=parser.parseOneLine();
        }
        catch (EndOfFile x) {}
        catch (EmptyLine x) {}

        return geom;
    }

    public static List makeGeOxygeneList(File file)
    throws Exception
    {
        return makeGeOxygeneList(new FileInputStream(file));
    }

    public static List makeGeOxygeneList(String wkt)
    throws Exception
    {
        InputStream in=new ByteArrayInputStream(wkt.getBytes());
        return makeGeOxygeneList(in);
    }

    public static List makeGeOxygeneList(InputStream in)
    throws ParseException
    {
        ArrayList list=new ArrayList();
        WktGeOxygene parser=new WktGeOxygene(in);

        while (true) {
            try {
                GM_Object geom=parser.parseOneLine();
                list.add(geom);
                        } catch (EndOfFile x) {
                break;
            } catch (EmptyLine x) {}
        }
        return list;
    }

    public static GM_Object makeGeOxygene(String inStr)
    throws ParseException
    {
        InputStream in=new ByteArrayInputStream(inStr.getBytes());
        return makeGeOxygene(in);
    }

  final public DirectPosition point() throws ParseException {
    DirectPosition p;
    Token xy;
    xy = jj_consume_token(POINT);
        StringTokenizer tkz=new StringTokenizer(xy.image);
        String xStr=tkz.nextToken();
        String yStr=tkz.nextToken();
        p=new DirectPosition(
            Double.parseDouble(xStr), Double.parseDouble(yStr));
        {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  final public DirectPosition pointText() throws ParseException {
 DirectPosition p=new DirectPosition();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      p = point();
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                   {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  final public GM_LineString linestringText() throws ParseException {
    GM_LineString lineString=new GM_LineString();
    DirectPosition p;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      p = point();
               lineString.addControlPoint(p);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 12:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        jj_consume_token(12);
        p = point();
                    lineString.addControlPoint(p);
      }
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return lineString;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Polygon polygonText() throws ParseException {
    GM_Polygon polygon=new GM_Polygon();
    GM_LineString lineString;
    DirectPosition start;
    DirectPosition end;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      lineString = linestringText();
                polygon=new GM_Polygon(lineString);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 12:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        jj_consume_token(12);
        lineString = linestringText();
            polygon.addInterior(new GM_Ring(lineString));
      }
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return polygon;}
    throw new Error("Missing return statement in function");
  }

  final public GM_MultiPoint multipointText() throws ParseException {
    GM_MultiPoint multiPoint=new GM_MultiPoint();
    DirectPosition p;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      p = point();
               multiPoint.add(new GM_Point(p));
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 12:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
        jj_consume_token(12);
        p = point();
                    multiPoint.add(new GM_Point(p));
      }
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return multiPoint;}
    throw new Error("Missing return statement in function");
  }

  final public GM_MultiCurve multilinestringText() throws ParseException {
    GM_MultiCurve multiLineString=new GM_MultiCurve();
    GM_LineString lineString;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      lineString = linestringText();
                                 multiLineString.add(lineString);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 12:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        jj_consume_token(12);
        lineString = linestringText();
         multiLineString.add(lineString);
      }
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return multiLineString;}
    throw new Error("Missing return statement in function");
  }

  final public GM_MultiSurface multipolygonText() throws ParseException {
    GM_MultiSurface multiPolygon=new GM_MultiSurface();
    GM_Polygon polygon;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      polygon = polygonText();
                           multiPolygon.add(polygon);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 12:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        jj_consume_token(12);
        polygon = polygonText();
                                multiPolygon.add(polygon);
      }
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return multiPolygon;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Aggregate geometrycollectionText() throws ParseException {
    GM_Aggregate geometryCollection=new GM_Aggregate();
    GM_Object geometry;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 9:
      jj_consume_token(9);
      geometry = geometryTaggedText();
                                   geometryCollection.add(geometry);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 12:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        jj_consume_token(12);
        geometry = geometryTaggedText();
         geometryCollection.add(geometry);
      }
      jj_consume_token(10);
      break;
    case 11:
      jj_consume_token(11);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return geometryCollection;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Point pointTaggedText() throws ParseException {
 DirectPosition p;
    jj_consume_token(13);
    p = pointText();
                    {if (true) return new GM_Point(p);}
    throw new Error("Missing return statement in function");
  }

  final public GM_MultiPoint multipointTaggedText() throws ParseException {
 GM_MultiPoint mp;
    jj_consume_token(14);
    mp = multipointText();
                          {if (true) return mp;}
    throw new Error("Missing return statement in function");
  }

  final public GM_LineString linestringTaggedText() throws ParseException {
 GM_LineString lineString;
    jj_consume_token(15);
    lineString = linestringText();
                                  {if (true) return lineString;}
    throw new Error("Missing return statement in function");
  }

  final public GM_MultiCurve multilinestringTaggedText() throws ParseException {
 GM_MultiCurve multiLineString;
    jj_consume_token(16);
    multiLineString = multilinestringText();
                                            {if (true) return multiLineString;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Polygon polygonTaggedText() throws ParseException {
 GM_Polygon poly;
    jj_consume_token(17);
    poly = polygonText();
                         {if (true) return poly;}
    throw new Error("Missing return statement in function");
  }

  final public GM_MultiSurface multipolygonTaggedText() throws ParseException {
 GM_MultiSurface mp;
    jj_consume_token(18);
    mp = multipolygonText();
                            {if (true) return mp;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Aggregate geometrycollectionTaggedText() throws ParseException {
 GM_Aggregate o;
    jj_consume_token(19);
    o = geometrycollectionText();
                                 {if (true) return o;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Object geometryTaggedText() throws ParseException {
 GM_Object o;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 13:
      o = pointTaggedText();
      break;
    case 15:
      o = linestringTaggedText();
      break;
    case 17:
      o = polygonTaggedText();
      break;
    case 14:
      o = multipointTaggedText();
      break;
    case 16:
      o = multilinestringTaggedText();
      break;
    case 18:
      o = multipolygonTaggedText();
      break;
    case 19:
      o = geometrycollectionTaggedText();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return o;}
    throw new Error("Missing return statement in function");
  }

  final public GM_Object parseOneLine() throws ParseException, EmptyLine, EndOfFile {
 GM_Object o;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      o = geometryTaggedText();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        jj_consume_token(EOL);
        break;
      case 0:
        jj_consume_token(0);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                           {if (true) return o;}
      break;
    case EOL:
      jj_consume_token(EOL);
             {if (true) throw new EmptyLine();} {if (true) return null;}
      break;
    case 0:
      jj_consume_token(0);
             {if (true) throw new EndOfFile();} {if (true) return null;}
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public WktGeOxygeneTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[16];
  final private int[] jj_la1_0 = {0xa00,0x1000,0xa00,0x1000,0xa00,0x1000,0xa00,0x1000,0xa00,0x1000,0xa00,0x1000,0xa00,0xfe000,0x41,0xfe041,};

  public WktGeOxygene(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new WktGeOxygeneTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public WktGeOxygene(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new WktGeOxygeneTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public WktGeOxygene(WktGeOxygeneTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(WktGeOxygeneTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[20];
    for (int i = 0; i < 20; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 16; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 20; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
