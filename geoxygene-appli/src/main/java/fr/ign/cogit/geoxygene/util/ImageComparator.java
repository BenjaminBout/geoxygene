/*******************************************************************************
 * This file is part of the GeOxygene project source files.
 * 
 * GeOxygene aims at providing an open framework which implements OGC/ISO
 * specifications for the development and deployment of geographic (GIS)
 * applications. It is a open source contribution of the COGIT laboratory at the
 * Institut Géographique National (the French National Mapping Agency).
 * 
 * See: http://oxygene-project.sourceforge.net
 * 
 * Copyright (C) 2005 Institut Géographique National
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library (see file LICENSE if present); if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307 USA
 *******************************************************************************/

package fr.ign.cogit.geoxygene.util;

import static org.lwjgl.opengl.GL11.GL_FRONT;
import static org.lwjgl.opengl.GL11.GL_RGBA;
import static org.lwjgl.opengl.GL11.glReadBuffer;
import static org.lwjgl.opengl.GL11.glReadPixels;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.util.Date;

import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;

import org.apache.log4j.Logger;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import fr.ign.cogit.geoxygene.appli.layer.LayerViewAwtPanel;
import fr.ign.cogit.geoxygene.appli.layer.LayerViewGLPanel;
import fr.ign.cogit.geoxygene.appli.render.AwtLayerRenderer;
import fr.ign.cogit.geoxygene.style.Layer;

/**
 * @author JeT
 *         Compar an image generated by a GL layer view to the same generated by
 *         the AWT reference
 */
public class ImageComparator implements MouseMotionListener, MouseListener, MouseWheelListener {

    private static final String RGB_DIFF_ITEM = "RGB difference";
    private static final String R_DIFF_ITEM = "R difference";
    private static final String G_DIFF_ITEM = "G difference";
    private static final String B_DIFF_ITEM = "B difference";
    private static final String RGB_BW_DIFF_ITEM = "RGB difference (B/W)";
    private static final String R_BW_DIFF_ITEM = "R difference (B/W)";
    private static final String G_BW_DIFF_ITEM = "G difference (B/W)";
    private static final String B_BW_DIFF_ITEM = "B difference (B/W)";

    private static final Logger logger = Logger.getLogger(ImageComparator.class.getName()); // logger

    private LayerViewGLPanel glLayerViewPanel = null;
    private JPanel mainPanel = null;
    private JButton refreshButton = null;
    private JComboBox cmpComboBox = null;
    private ImagePanel glPanel = null;
    private ImagePanel awtPanel = null;
    LayerViewAwtPanel awtLayerViewPanel = new LayerViewAwtPanel();
    private ImagePanel cmpPanel = null;
    private JTabbedPane tabbedPane = null;

    // transformation handler
    private int lastOffsetX = 0;
    private int lastOffsetY = 0;
    private double translateX = 0;
    private double translateY = 0;
    private double scale = 1.;
    private BufferedImage glImage = null;
    private BufferedImage awtImage = null;
    private BufferedImage cmpImage = null;

    /**
     * Constructor
     * 
     * @param layerViewGLPanel
     */
    public ImageComparator(LayerViewGLPanel layerViewGLPanel) {
        this.glLayerViewPanel = layerViewGLPanel;
    }

    /**
     * GUI accessor
     */
    public JComponent getGui() {
        return this.getMainPanel();
    }

    private JPanel getMainPanel() {
        if (this.mainPanel == null) {
            this.mainPanel = new JPanel(new BorderLayout());
            JPanel northPanel = new JPanel(new BorderLayout(5, 2));
            northPanel.add(this.getCmpComboBox(), BorderLayout.CENTER);
            northPanel.add(this.getRefreshButton(), BorderLayout.EAST);
            this.mainPanel.add(northPanel, BorderLayout.NORTH);
            this.mainPanel.add(this.getTabbedPane(), BorderLayout.CENTER);
        }
        return this.mainPanel;
    }

    private ImagePanel getGlPanel() {
        if (this.glPanel == null) {
            this.glPanel = new ImagePanel();
            this.glPanel.addMouseMotionListener(this);
            this.glPanel.addMouseListener(this);
            this.glPanel.addMouseWheelListener(this);
        }
        return this.glPanel;
    }

    private JComboBox getCmpComboBox() {
        if (this.cmpComboBox == null) {
            this.cmpComboBox = new JComboBox();
            this.cmpComboBox.addItem(RGB_DIFF_ITEM);
            this.cmpComboBox.addItem(R_DIFF_ITEM);
            this.cmpComboBox.addItem(G_DIFF_ITEM);
            this.cmpComboBox.addItem(B_DIFF_ITEM);
            this.cmpComboBox.addItem(RGB_BW_DIFF_ITEM);
            this.cmpComboBox.addItem(R_BW_DIFF_ITEM);
            this.cmpComboBox.addItem(G_BW_DIFF_ITEM);
            this.cmpComboBox.addItem(B_BW_DIFF_ITEM);
            this.cmpComboBox.addItemListener(new ItemListener() {

                @Override
                public void itemStateChanged(ItemEvent e) {
                    ImageComparator.this.cmpImage = null;
                    ImageComparator.this.getTabbedPane().setSelectedIndex(2);
                    ImageComparator.this.update();
                }
            });
        }
        return this.cmpComboBox;
    }

    private JButton getRefreshButton() {
        if (this.refreshButton == null) {
            this.refreshButton = new JButton("refresh");
            this.refreshButton.addActionListener(new ActionListener() {

                @Override
                public void actionPerformed(ActionEvent e) {
                    ImageComparator.this.glImage = null;
                    ImageComparator.this.awtImage = null;
                    ImageComparator.this.cmpImage = null;
                    ImageComparator.this.update();

                }
            });
        }
        return this.refreshButton;
    }

    private ImagePanel getAwtPanel() {
        if (this.awtPanel == null) {
            this.awtPanel = new ImagePanel();
            this.awtPanel.addMouseMotionListener(this);
            this.awtPanel.addMouseListener(this);
            this.awtPanel.addMouseWheelListener(this);
        }
        return this.awtPanel;
    }

    private ImagePanel getCmpPanel() {
        if (this.cmpPanel == null) {
            this.cmpPanel = new ImagePanel();
            this.cmpPanel.addMouseMotionListener(this);
            this.cmpPanel.addMouseListener(this);
            this.cmpPanel.addMouseWheelListener(this);
        }
        return this.cmpPanel;
    }

    private JTabbedPane getTabbedPane() {
        if (this.tabbedPane == null) {
            this.tabbedPane = new JTabbedPane();
            this.tabbedPane.addTab("gl", this.getGlPanel());
            this.tabbedPane.addTab("awt", this.getAwtPanel());
            this.tabbedPane.addTab("comp", this.getCmpPanel());
        }
        return this.tabbedPane;
    }

    public void update() {
        AffineTransform transform = new AffineTransform();
        transform.translate(this.translateX, this.translateY);
        transform.scale(this.scale, this.scale);
        this.getGlPanel().setImage(this.getGlImage());
        this.getAwtPanel().setImage(this.getAwtImage());
        this.getCmpPanel().setImage(this.getCmpImage());
        this.getGlPanel().setTransform(transform);
        this.getCmpPanel().setTransform(transform);
        this.getAwtPanel().setTransform(transform);
        this.getGlPanel().repaint();
        this.getCmpPanel().repaint();
        this.getAwtPanel().repaint();
    }

    private BufferedImage getGlImage() {
        if (this.glImage == null) {
            this.glLayerViewPanel.activateGLContext();
            int width = this.glLayerViewPanel.getWidth();
            int height = this.glLayerViewPanel.getHeight();
            int bpp = 4; // Assuming a 32-bit display with a byte each for red, green, blue, and alpha.
            java.nio.ByteBuffer buffer = BufferUtils.createByteBuffer(width * height * bpp);
            glReadBuffer(GL_FRONT);
            glReadPixels(0, 0, width, height, GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);
            this.glImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    int i = (x + (width * y)) * bpp;
                    int r = buffer.get(i) & 0xFF;
                    int g = buffer.get(i + 1) & 0xFF;
                    int b = buffer.get(i + 2) & 0xFF;
                    this.glImage.setRGB(x, height - (y + 1), (0xFF << 24) | (r << 16) | (g << 8) | b);
                }
            }
        }
        return this.glImage;
    }

    private BufferedImage getAwtImage() {
        if (this.awtImage == null) {

            this.awtLayerViewPanel.setProjectFrame(this.glLayerViewPanel.getProjectFrame());
            this.awtLayerViewPanel.setViewport(this.glLayerViewPanel.getViewport());
            // manually add all layers (which are normally added by listening to the sld)
            for (Layer l : this.glLayerViewPanel.getProjectFrame().getSld().getLayers()) {
                this.awtLayerViewPanel.getRenderingManager().addLayer(l);
            }
            int width = this.glLayerViewPanel.getWidth();
            int height = this.glLayerViewPanel.getHeight();
            // initialize renderers images manually because default initialization uses
            // panel size which is 0x0 (panel is not displayed on screen)
            for (AwtLayerRenderer renderer : this.awtLayerViewPanel.getRenderingManager().getRenderers()) {
                renderer.setOffscreenWidth(width);
                renderer.setOffscreenHeight(height);
                renderer.setImage(new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB));
            }
            this.awtLayerViewPanel.repaint();
            while (this.awtLayerViewPanel.getRenderingManager().isRendering()) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            this.awtImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
            Graphics2D g = (Graphics2D) this.awtImage.getGraphics();
            g.setColor(this.awtLayerViewPanel.getBackground());
            g.fillRect(0, 0, width, height);
            this.awtLayerViewPanel.getRenderingManager().copyTo(g);
        }
        return this.awtImage;
    }

    private BufferedImage getCmpImage() {
        if (this.cmpImage == null) {
            if (RGB_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeRgbDiffCmpImage(false);
            } else if (R_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeRDiffCmpImage(false);
            } else if (G_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeGDiffCmpImage(false);
            } else if (B_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeBDiffCmpImage(false);
            } else if (RGB_BW_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeRgbDiffCmpImage(true);
            } else if (R_BW_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeRDiffCmpImage(true);
            } else if (G_BW_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeGDiffCmpImage(true);
            } else if (B_BW_DIFF_ITEM.equals(this.getCmpComboBox().getSelectedItem())) {
                this.cmpImage = this.computeBDiffCmpImage(true);
            } else {
                logger.error("Don't know how to handle comparison method '" + this.getCmpComboBox().getSelectedItem() + "'");
            }

        }
        return this.cmpImage;
    }

    private BufferedImage computeRgbDiffCmpImage(boolean BW) {
        BufferedImage ref = this.getAwtImage();
        BufferedImage image = this.getGlImage();
        if (ref == null || image == null) {
            logger.warn("Cannot compute comparison image " + ref + " / " + image);
            return null;
        }
        BufferedImage resultImage = new BufferedImage(ref.getWidth(), ref.getHeight(), BufferedImage.TYPE_INT_ARGB);

        for (int h = 0; h < ref.getHeight(); h++) {
            for (int w = 0; w < ref.getWidth(); w++) {
                int alpha1 = 0xff & (ref.getRGB(w, h) >> 24);
                int red1 = 0xff & (ref.getRGB(w, h) >> 16);
                int green1 = 0xff & (ref.getRGB(w, h) >> 8);
                int blue1 = 0xff & ref.getRGB(w, h);

                int alpha2 = 0xff & (image.getRGB(w, h) >> 24);
                int red2 = 0xff & (image.getRGB(w, h) >> 16);
                int green2 = 0xff & (image.getRGB(w, h) >> 8);
                int blue2 = 0xff & image.getRGB(w, h);

                //euclidian distance to estimate the simil.
                if (BW) {
                    int dr = Math.abs(red1 - red2);
                    int dg = Math.abs(green1 - green2);
                    int db = Math.abs(blue1 - blue2);
                    resultImage.setRGB(w, h, new Color(dr, dg, db).getRGB());
                } else {
                    int dr = (red1 - red2) / 2 + 128;
                    int dg = (green1 - green2) / 2 + 128;
                    int db = (blue1 - blue2) / 2 + 128;
                    resultImage.setRGB(w, h, new Color(dr, dg, db).getRGB());

                }
            }

        }
        return resultImage;
    }

    private BufferedImage computeBDiffCmpImage(boolean BW) {
        BufferedImage ref = this.getAwtImage();
        BufferedImage image = this.getGlImage();
        if (ref == null || image == null) {
            logger.warn("Cannot compute comparison image " + ref + " / " + image);
            return null;
        }
        BufferedImage resultImage = new BufferedImage(ref.getWidth(), ref.getHeight(), BufferedImage.TYPE_INT_ARGB);

        for (int h = 0; h < ref.getHeight(); h++) {
            for (int w = 0; w < ref.getWidth(); w++) {
                int blue1 = 0xff & ref.getRGB(w, h);
                int blue2 = 0xff & image.getRGB(w, h);
                //euclidian distance to estimate the simil.
                if (BW) {
                    int db = Math.abs(blue1 - blue2);
                    resultImage.setRGB(w, h, new Color(db, db, db).getRGB());
                } else {
                    int db = (blue1 - blue2) / 2 + 128;
                    resultImage.setRGB(w, h, new Color(db, db, db).getRGB());

                }
            }

        }
        return resultImage;
    }

    private BufferedImage computeGDiffCmpImage(boolean BW) {
        BufferedImage ref = this.getAwtImage();
        BufferedImage image = this.getGlImage();
        if (ref == null || image == null) {
            logger.warn("Cannot compute comparison image " + ref + " / " + image);
            return null;
        }
        BufferedImage resultImage = new BufferedImage(ref.getWidth(), ref.getHeight(), BufferedImage.TYPE_INT_ARGB);

        for (int h = 0; h < ref.getHeight(); h++) {
            for (int w = 0; w < ref.getWidth(); w++) {
                int green1 = 0xff & (ref.getRGB(w, h) >> 8);
                int green2 = 0xff & (image.getRGB(w, h) >> 8);
                //euclidian distance to estimate the simil.
                if (BW) {
                    int dg = Math.abs(green1 - green2);
                    resultImage.setRGB(w, h, new Color(dg, dg, dg).getRGB());
                } else {
                    int dg = (green1 - green2) / 2 + 128;
                    resultImage.setRGB(w, h, new Color(dg, dg, dg).getRGB());

                }
            }

        }
        return resultImage;
    }

    private BufferedImage computeRDiffCmpImage(boolean BW) {
        BufferedImage ref = this.getAwtImage();
        BufferedImage image = this.getGlImage();
        if (ref == null || image == null) {
            logger.warn("Cannot compute comparison image " + ref + " / " + image);
            return null;
        }
        BufferedImage resultImage = new BufferedImage(ref.getWidth(), ref.getHeight(), BufferedImage.TYPE_INT_ARGB);

        for (int h = 0; h < ref.getHeight(); h++) {
            for (int w = 0; w < ref.getWidth(); w++) {
                int red1 = 0xff & (ref.getRGB(w, h) >> 16);
                int red2 = 0xff & (image.getRGB(w, h) >> 16);
                if (BW) {
                    int dr = Math.abs(red1 - red2);
                    resultImage.setRGB(w, h, new Color(dr, dr, dr).getRGB());
                } else {
                    int dr = (red1 - red2) / 2 + 128;
                    resultImage.setRGB(w, h, new Color(dr, dr, dr).getRGB());

                }

            }
        }
        return resultImage;
    }

    /*************************************************************************************************
     * Affine transformation event handling
     */
    @Override
    public void mousePressed(MouseEvent e) {
        // capture starting point
        this.lastOffsetX = e.getX();
        this.lastOffsetY = e.getY();
    }

    @Override
    public void mouseDragged(MouseEvent e) {

        // new x and y are defined by current mouse location subtracted
        // by previously processed mouse location
        int newX = e.getX() - this.lastOffsetX;
        int newY = e.getY() - this.lastOffsetY;

        // increment last offset to last processed by drag event.
        this.lastOffsetX += newX;
        this.lastOffsetY += newY;

        // update the canvas locations
        this.translateX += newX;
        this.translateY += newY;

        // schedule a repaint.
        this.update();
    }

    @Override
    public void mouseClicked(MouseEvent e) {
    }

    @Override
    public void mouseEntered(MouseEvent e) {
    }

    @Override
    public void mouseExited(MouseEvent e) {
    }

    @Override
    public void mouseMoved(MouseEvent e) {
    }

    @Override
    public void mouseReleased(MouseEvent e) {
    }

    @Override
    public void mouseWheelMoved(MouseWheelEvent e) {
        if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {

            this.translateX -= e.getX();
            this.translateY -= e.getY();
            this.translateX /= this.scale;
            this.translateY /= this.scale;
            // make it a reasonable amount of zoom
            // .1 gives a nice slow transition
            this.scale /= 1 + (.1 * e.getWheelRotation());
            // don't cross negative threshold.
            // also, setting scale to 0 has bad effects
            this.scale = Math.max(0.1, this.scale);
            this.scale = Math.min(10, this.scale);

            this.translateX *= this.scale;
            this.translateY *= this.scale;
            this.translateX += e.getX();
            this.translateY += e.getY();

            this.update();
        }
    }

    /******************************************************************
     * panel displaying an image with an affine transform
     */
    private class ImagePanel extends JPanel {

        private AffineTransform transform;
        private Image image;

        /*
         * (non-Javadoc)
         * 
         * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
         */
        @Override
        protected void paintComponent(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.setColor(Color.black);
            g2.fillRect(0, 0, this.getWidth(), this.getHeight());
            if (this.getImage() == null) {
                g2.setColor(Color.white);
                g2.drawString("No valid Image", 10, 10);
                return;
            }
            g2.drawImage(this.getImage(), this.getTransform(), null);
            //            super.paintComponent(g);
        }

        private AffineTransform getTransform() {
            return this.transform;
        }

        private Image getImage() {
            return this.image;
        }

        /**
         * @param transform
         *            the transform to set
         */
        public void setTransform(AffineTransform transform) {
            this.transform = transform;
        }

        /**
         * @param image
         *            the image to set
         */
        public void setImage(Image image) {
            this.image = image;
        }

    }
}
